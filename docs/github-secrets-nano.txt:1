  - CORS_ORIGIN
      - Value: http://localhost:3000
  - METRICS_TOKEN
      - Value:
        c9d3b0139a614d9ebdf65f17a8a2e7e9bb457a6ae1d3d4920b754e23e9bd18a1
  - ADMIN_SESSION_SECRET
      - Value:
        f57cf8e0a8b14ec3a3c6b28a9b61a4d8e5e7f3c9d2a14f0ddf93a62c4b7e89ab
  - FAN_SESSION_SECRET
      - Value:
        a2e75b19d5c14b42a9f2e37ccbe1a9cf6fd1c82a4b75d0e4911a2f833ac5b46d
  - INSTALL_CERT_MANAGER
      - Value: 1
  - REDIS_URL
      - Value: redis://localhost:6379
      - Note: This is fine for passing CI checks. For production you’ll set a
        real managed Redis URL later.

  Leave these empty unless you’re ready to use them

  - DATABASE_SHADOW_URL: leave blank (not required for deploy migrations)
  - HEALTH_URL: leave blank (CI skips health step if empty)
  - GHCR_TOKEN: leave blank if your images are public; CI will skip creating a
    pull secret

  Generate these on your machine (exact commands)

  - KUBE_CONFIG_B64 (prints base64 of your kubeconfig)
      - macOS: base64 < ~/.kube/config | pbcopy
      - Linux: base64 -w0 < ~/.kube/config | xclip -sel clip
      - Windows PowerShell:
        [Convert]::ToBase64String([IO.File]::ReadAllBytes("$env:USERPROFILE.ku
        be\config"))
  - GHCR_TOKEN (personal access token with read:packages)
      - GitHub web: Profile → Settings → Developer settings → Personal access
        tokens → New token → scope “read:packages” → copy token and use as
        GHCR_TOKEN
      - Note: This cannot be auto‑generated from here for security.
  - CERT_MANAGER_EMAIL
      - Use your real email address (for Let’s Encrypt notifications)
  - INGRESS_HOST
      - Use your real domain (the hostname users visit)
      - Ensure DNS A/AAAA record points to your ingress controller’s public IP
  - TLS_SECRET
      - Any Kubernetes secret name for the certificate (e.g., app-yourdomain-
        tls)
      - cert‑manager will create it automatically once Ingress and
        ClusterIssuer are applied
